const MAX_VAL:i32 = 1000;
fn main() {

    //数据类型
    /*
    参考资料：https://course.rs/basic/base-type/numbers.html （rust圣经）
        数据类型可以分为两类：基本类型和符合类型。
        基本类型：
            数值类型：有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
                - 类型定义的形式统一为：有无符号 + 类型大小(位数)。无符号数表示数字只能取正数和0，而有符号则表示数字可以取正数、负数还有0。
                - 每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度
                - isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。
           
            浮点类型：字符串字面量和字符串切片 &str
                - 避免在浮点数上测试相等性
                - 操作浮点数时要格外的小心
            
            布尔类型：true 和 false.
            
            字符类型：表示单个 Unicode 字符，存储为 4 个字节
                -Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 U+0000 ~ U+D7FF 和 U+E000 ~ U+10FFFF。
            
            单元类型: 即  () ，其唯一的值也是  ().
            
     */

    //代码示例1:整数溢出
    /* 
        //Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)
        let num:u8 = 256;//溢出
        println!("num is val = {num}");  //<==> println!("num is val = {}", num); 
    */

    //代码示例2：浮点测试
    /*
        let a:(f32,f32,f32)  = (0.1,0.2,0.3);
        let x:(f64,f64,f64)  = (0.1,0.2,0.3);
        println!("0.1 + 0.2 = {}",a.0 + a.1); // 0.3
        println!("0.3 = {}", a.2);

        println!("0.1 + 0.2 = {}",x.0 + x.1); // 0.30000000000000004
        println!("0.3 = {}", x.2);
    */

    //代码测试3：NaN (not a number)
    /*
        //所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较
        //出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：
    
        let n = (-42.0_f32).sqrt();
        println!("val: {}",n);
        // assert_eq!(n, n);
        if n.is_nan(){   // true
            println!("未定义的数学行为");
        }
    */

    //代码测试4：序列(Range)
    /*
        //Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中

        for i in 1..5 { //不包含5
            println!("i = {i}");
        }

        for i in 1..=5 { //包含5
            println!("i = {i}");
        }
     */

    //代码测试5：字符类型
    /*
        //单引号引起来的都是字符类型
        let c = 'z';
        let g = '国';
        let e = '😻';
        println!("c = {},g = {}, e = {}",c,g,e);
     */

    //代码测试6：语句和表达式
    /* 
        //语句没有返回值，表达式有返回值并且表达式不能包含分号,一旦你在表达式后加上分号，它就会变成一条语句  
        //表达式会进行求值，然后返回一个值
        fn _demo(x:i32, y:i32) -> i32 {
            let x = x + 10; //语句
            let y  = y + 20; //语句
            x + y //表达式
            //上述函数体的三行代码中，前两行是语句，最后一行是表达式,表达式有返回值
        }

        //用花括号包裹最终返回一个值的语句块也是表达式
        //最后，表达式如果不返回任何值，会隐式地返回一个 () 。
        let y = {
            let x = 3;
            x + 1
        };
        println!("The value of y is: {}", y); //4
  
        */

    println!("Hello, world! const = {}", MAX_VAL);
}
